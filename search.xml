<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>在gradle管理可共享的依赖版本</title>
    <url>/2020/06/04/%E5%9C%A8gradle%E7%AE%A1%E7%90%86%E5%8F%AF%E5%85%B1%E4%BA%AB%E7%9A%84%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>“可共享的依赖版本管理” —— 用过 Maven 的小伙伴们可能说，这不就是BOM么。<br>对，这里聊的就是如何使用 gradle 实现 BOM 生成和导入。<br>没用过 Maven 的小伙伴们也不用被劝退，想想在使用Spring plugin <code>io.spring.dependency-management</code>时，<br><code>imports.mavenBom</code>到底在做什么，有没有想要了解一下？</p>
<a id="more"></a>

<h2 id="BOM是什么？"><a href="#BOM是什么？" class="headerlink" title="BOM是什么？"></a>BOM是什么？</h2><p>在说 BOM 之前，先了解一下 Maven 的一些基本概念。<br>Maven <strong>POM</strong>，全名 <code>Project Object Model</code>, 是 Maven 使用中的重要配置文件，xml格式，主要用来导入依赖和进行项目构建。<br>Maven <strong>BOM</strong>, 全名 <code>Bill Of Materials</code>, 是一种特殊的 POM，主要用来集中管理项目依赖的版本，更加灵活地维护所有依赖的版本信息。<br>配置好的 BOM，可以放在单个项目中自用，也可以传阅和分享给其他项目进行公用。</p>
<p>讲的直观一点，效果就是（见下图）：<br><img src="/2020/06/04/%E5%9C%A8gradle%E7%AE%A1%E7%90%86%E5%8F%AF%E5%85%B1%E4%BA%AB%E7%9A%84%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC/Spring-dependencies-management.png" alt="Spring-dependencies-management"><br>dependencies中依赖的那些库为何可以不用标明版本？<br>正是因为使用了<em>dependency-management</em> 插件，当 gradle plugin <em>org.springframework.boot</em> 检测到此插件启用时，会自动导入Spring boot dependencies BOM，这样依赖库们会主动使用 BOM 中推荐的版本。</p>
<p>下面是Spring Cloud BOM的一部分展示(完整见<a href="https://github.com/spring-cloud/spring-cloud-release/blob/vHoxton.SR5/spring-cloud-dependencies/pom.xml" target="_blank" rel="noopener">链接</a>)：</p>
<p><img src="/2020/06/04/%E5%9C%A8gradle%E7%AE%A1%E7%90%86%E5%8F%AF%E5%85%B1%E4%BA%AB%E7%9A%84%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC/Spring-cloud-dependencies.png" alt="Spring-cloud-dependencies"></p>
<p>看到这里，是不是觉得有 BOM 的情况下便捷不少，再也不用一条条dependency分别查阅、选择和维护版本了？<br>日常开发中，我们已经见识过了Spring boot / Spring Cloud /junit 这些常用 BOMs。</p>
<p>当有了已经被验证过的依赖版本管理，setup projects时候直接拿来复用，是不是感觉省事不少？<br>同时 BOM 不可避免地还支持版本升级。<br>下面我们就来看看如何在 gradle 中定义我们自己的 BOM。</p>
<h2 id="gradle-Java-platform-plugin"><a href="#gradle-Java-platform-plugin" class="headerlink" title="gradle Java platform plugin"></a>gradle Java platform plugin</h2><p><code>gradle Java platform plugin</code>是 gradle 对定义、发布 BOM 提供的一款实用插件。<br>引入它，我们就可以开始动手工作了。<a href="https://docs.gradle.org/5.6.3/userguide/java_platform_plugin.html#header" target="_blank" rel="noopener">官方链接</a></p>
<p><em><code>build.gradle</code></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &#39;maven-publish&#39;</span><br><span class="line">    id &#39;java-platform&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">version &#39;0.1.1-SNAPSHOT&#39;</span><br><span class="line"></span><br><span class="line">javaPlatform &#123;</span><br><span class="line">    allowDependencies()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    api platform(&#39;org.springframework.boot:spring-boot-dependencies:2.2.6.RELEASE&#39;)</span><br><span class="line">    api platform(&#39;org.springframework.cloud:spring-cloud-dependencies:Greenwich.SR3&#39;)</span><br><span class="line">    api platform(&#39;org.springframework.cloud:spring-cloud-contract-dependencies:2.2.3.RELEASE&#39;)</span><br><span class="line">    api platform(&#39;org.junit:junit-bom:5.3.2&#39;)</span><br><span class="line">    constraints &#123;</span><br><span class="line">        api &#39;com.google.guava:guava:27.0.1-jre&#39;</span><br><span class="line"></span><br><span class="line">        api &#39;ch.vorburger.mariaDB4j:mariaDB4j-springboot:2.4.0&#39;</span><br><span class="line">        api &#39;org.mariadb.jdbc:mariadb-java-client:2.2.5&#39;</span><br><span class="line"></span><br><span class="line">        api &#39;org.mockito:mockito-core:2.22.0&#39;</span><br><span class="line">        api &#39;org.mockito:mockito-junit-jupiter:2.22.0&#39;</span><br><span class="line">        api &#39;org.assertj:assertj-core:3.11.1&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publishing &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username &#x3D; &#39;jfrog&#39;</span><br><span class="line">                password &#x3D; &#39;jfrog123456&#39;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            def releasesRepoUrl &#x3D; &#39;http:&#x2F;&#x2F;localhost:8082&#x2F;artifactory&#x2F;libs-release&#x2F;&#39;</span><br><span class="line">            def snapshotsRepoUrl &#x3D; &#39;http:&#x2F;&#x2F;localhost:8082&#x2F;artifactory&#x2F;libs-snapshot&#x2F;&#39;</span><br><span class="line">            url &#x3D; version.endsWith(&#39;SNAPSHOT&#39;) ? snapshotsRepoUrl : releasesRepoUrl</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publications &#123;</span><br><span class="line">        myPlatform(MavenPublication) &#123;</span><br><span class="line">            from components.javaPlatform</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然, 作为一个服务级的 BOM，自然无需从零开始逐条定义，可以直接先 import 框架级的 BOMs，如上例中的Spring boot / Spring cloud / Spring cloud contract / Junit。<br>但用于需要使用第三方platform bom, 则不得不打开配置约束 ——<code>javaPlatform.allowDependencies</code>。具体使用请见<a href="https://docs.gradle.org/5.6.3/userguide/java_platform_plugin.html#sec:java_platform_bom_import" target="_blank" rel="noopener">官方链接</a></p>
<p>这里，通过gradle生成的 BOM 会发布到一个我本地自己搭建的JFrog artifactory OSS中。<br>(为什么不在云上搭一个？啊哈哈，因为JFrog artifactory OSS最低预配是4核4G内存，自己掏钱就手短了。。)<br>当然,也可以生成本地的 POM 文件，手动复制传阅，但这样就不容易进行后续的版本管理和保持更新了。</p>
<p>maven publish 成功后，我们就可以来使用 BOM 导入依赖版本了。</p>
<h2 id="gradle-platform"><a href="#gradle-platform" class="headerlink" title="gradle platform"></a>gradle platform</h2><p>导入方式也非常简单，直接使用platform组件即可。<a href="https://docs.gradle.org/current/userguide/platforms.html" target="_blank" rel="noopener">官方链接</a></p>
<p>创建一个example项目试一下, 编写<code>build.gradle</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        credentials &#123;</span><br><span class="line">            username &#x3D; &quot;jfrog&quot;</span><br><span class="line">            password &#x3D; &quot;jfrog123456&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        url &quot;http:&#x2F;&#x2F;localhost:8082&#x2F;artifactory&#x2F;libs-snapshot&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation platform(&#39;com.ellendan.service.template:dependencies-bom:0.1.1-SNAPSHOT&#39;)</span><br><span class="line"></span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</span><br><span class="line">    implementation &#39;org.springframework.boot:spring-boot-starter-security&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对，就是使用platform()引入即可。  </p>
<p>也许有人会问：大家用 spring-dependency-management 习惯了，这个 BOM 是否支持 spring-dependency-management 的 <code>imports.mavenBom</code>。<br>理论上是支持的。<br>但本人在写代码的时候，发现自定义 BOM 中spring boot dependencies BOM 无法被成功引入，而其他 BOMs 都没有此问题、可以成功导入。<br>因此，我这里并不推荐通过spring-dependency-management的<code>imports.mavenBom</code>来导入。</p>
<h2 id="为什么要做“可共享的依赖版本管理”"><a href="#为什么要做“可共享的依赖版本管理”" class="headerlink" title="为什么要做“可共享的依赖版本管理”"></a>为什么要做“可共享的依赖版本管理”</h2><p>这还要从本人最近的一个任务说起。<br>任务本身是做 —— “启动模板”。<br>但“启动模板”，这四个字，怎么看都觉得非常的静态。<br>结合Rebecca《演进式架构》中“服务模板”的概念（虽然“模板”这命名还是怎么看怎么静态），为了防止有害的重复，如果有时候技术上的适当耦合避免不了，那就尽量让其黑盒复用。  </p>
<blockquote>
<p>通过在服务模板中定义适当的技术架构耦合点，并让基础设施团队管理这些耦合，就能使各个服务团队免于这些苦恼。  </p>
</blockquote>
<p>所以，这里决定尝试做一个“服务模板”。<br>依赖版本管理只是其中的一个小的部分。  </p>
<h4 id="PS-废话篇"><a href="#PS-废话篇" class="headerlink" title="PS. 废话篇"></a>PS. 废话篇</h4><p>眼看2020就要过半，由于2020开局乱来，受种种因素影响，计划一团混乱变更。<br>一鼓作气，再而衰，三而竭，各种计划目标债。期望2020后半段能走好吧~</p>
]]></content>
  </entry>
  <entry>
    <title>DDD概念概览</title>
    <url>/2020/02/09/DDD%E6%A6%82%E5%BF%B5%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>软件的核心，是为其用户解决领域相关问题的能力。</p>
<h3 id="何为DDD"><a href="#何为DDD" class="headerlink" title="何为DDD"></a>何为DDD</h3><p>DDD是Domain Driven Design的简称。<strong>领域驱动设计</strong>，“<strong>领域</strong>”指业务领域，“<strong>设计</strong>”指软件设计。<br>DDD可以看成一种开发思想体系，促成了一种新的以领域为中心的思维方式，使得团队可以高效管理——用于复杂问题域的软件的构造和维护。</p>
<a id="more"></a>

<h3 id="为什么DDD"><a href="#为什么DDD" class="headerlink" title="为什么DDD"></a>为什么DDD</h3><p>对于一个复杂业务系统，无视业务复杂度而割裂式地进行软件设计，往往会造成软件的<strong>大泥球模式（BBoM）</strong>，后果就是：</p>
<ol>
<li>对统一语言和问题域知识缺乏重视，导致代码库可用但无法揭示业务意图。</li>
<li>缺乏基于问题域模型的应用程序设计的重视，让代码库缺乏与业务行为的协同效应，当有后续功能的扩展就会变得棘手。领域复杂性和技术复杂性混合在了一起。</li>
<li>会扼杀开发。对开发人员来说，软件杂乱、变更易出错。对企业来说，降低了软件快速实现商业价值的能力。</li>
<li>缺乏对问题域的关注和正确认识，构建出来的软件系统往往会失败。<br>注：<strong>问题域</strong> ，涉及你当前正在构建软件的主题领域。是确定软件价值的关键点。</li>
</ol>
<h3 id="DDD模式"><a href="#DDD模式" class="headerlink" title="DDD模式"></a>DDD模式</h3><p>DDD具有两种模式类型：战略模式和战术模式。<br>战略模式影响的是解决方案，战术模式用于实现富领域模型。<br><img src="/2020/02/09/DDD%E6%A6%82%E5%BF%B5%E6%A6%82%E8%A7%88/ddd-summary.png" alt="Domain Drive Design Summary.png"></p>
<h4 id="DDD战略模式"><a href="#DDD战略模式" class="headerlink" title="DDD战略模式"></a>DDD战略模式</h4><p>领域驱动设计的战略模式会提炼问题域并塑造应用程序的架构。</p>
<ol>
<li>提炼问题域以揭示重要之处是什么 —— 核心子域。核心域是编写软件的原因，保留最大价值的关键区域，决定软件成功与否的关键。并非一个系统的所有部分都需要被精心设计，团队可以更专注于核心领域。</li>
<li>在解空间构建一个软件模型，以处理领域问题并让软件与业务保持一致。</li>
<li>运用统一语言（Ubiquitous Language），开启建模协作。首先，确保的是领域专家和开发团队协作工作，其次，是将分析模型绑定到代码模型，以便开发团队和领域专家能够在模型设计方面进行协作。</li>
<li>限界上下文（Bounded Context），定义了模型的适用性并确保保留其完整性和独立发展的能力。统一语言和模型的适用边界应该是要在具体的限界上下文内。</li>
<li>上下文映射（Context Map）。上下文映射提供了整个系统各上下文边界之间的宏观状况，揭示了上下文之间的关系和交互方式，同时表现出各上下文内模型的有多少差异，以及它们的交换哪些数据来实现业务处理过程。</li>
</ol>
<p><strong>问题空间 &amp; 解空间</strong><br>战略模式中强调问题空间和解空间的区别。只有明确确定了问题空间，才能分析出对应的解空间，最终才能构建出满足解决业务问题的成功软件。<br>上1，是解决问题空间复杂度的管理模式。问题空间将问题提炼成更多可管理的子域。<br>上2、3、4、5， 是解空间的管理模式。</p>
<p>战略模式强调了DDD的侧重点是：知识消化、知识提炼、协作沟通、统一语言、上下文、模型持续发展。<br>后面战术模式，其实只是支持其实现而推荐的手段。</p>
<h4 id="DDD战术模式"><a href="#DDD战术模式" class="headerlink" title="DDD战术模式"></a>DDD战术模式</h4><p>DDD的战术模式（也称模型构造块）是一个帮助创建用于复杂有界上下文的有效模型的模式集合。<br>许多模式都早于DDD概念的出现，但依然有一些被推荐为DDD战术的标准模式。<br>在战略模式提供的架构和原则的基础上，共用这些标准模式可以让设计有序进行，也使项目组成员能够更方便地了解彼此的工作内容。</p>
<ol>
<li>实体（Entity）</li>
<li>值对象（Value Object）</li>
<li>领域服务（Domain Service）</li>
<li>工厂(Factory)和验证器(Validator)</li>
<li>聚合(Aggregation)</li>
<li>资源库(Repository)</li>
<li>领域事件(Domain Event)</li>
<li>模块(Module)</li>
<li>集成限界上下文</li>
<li>六边形架构</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>《领域驱动设计：软件核心复杂性应对之道》，Eric Evans 著</li>
<li>《实现领域驱动设计》，Vaughn Vemon 著</li>
<li>《领域驱动设计模式、原理与实践》，Scott Millett / Nick Tune 著</li>
</ol>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>从精益来看价值交付是什么</title>
    <url>/2020/02/08/%E4%BB%8E%E7%B2%BE%E7%9B%8A%E6%9D%A5%E7%9C%8B%E4%BB%B7%E5%80%BC%E4%BA%A4%E4%BB%98%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>前一段时间在做U内的价值交付。<br>个人也从最开始的可意会不可言传的状态，到后来可以聊些概念和措施的阶段。</p>
<p>老实说，曾经在我司经常听到Dev challenge BA：“你这个需求的价值是什么？”现在反而听到越来越少。<br>曾经我们坚持要去做有价值的事情，直到我们现在不得不 highlight 出 <code>价值交付</code> 这个标题。<br>并且常常会被问到 —— 价值交付，它到底指什么？</p>
<a id="more"></a>

<h2 id="“价值交付是什么？”"><a href="#“价值交付是什么？”" class="headerlink" title="“价值交付是什么？”"></a>“价值交付是什么？”</h2><p>首先，我不会尝试直接回答这个问题。<br>作为一个交付型U，我们先从一些耳熟能详的理论和方法实践中，尝试找到“价值”这个词。</p>
<ol>
<li><p>敏捷软件开发宣言</p>
<blockquote>
<p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。<br>由此我们建立了如下价值观：</p>
<p>个体和互动 高于 流程和工具<br>工作的软件 高于 详尽的文档<br>客户合作 高于 合同谈判<br>响应变化 高于 遵循计划</p>
<p>也就是说，尽管右项有其价值，<br>我们更重视左项的价值。</p>
</blockquote>
</li>
<li><p>相互依赖声明（敏捷项目管理宣言）</p>
<blockquote>
<p>敏捷和自适应的方法把人、项目和价值联系起来<br>我们是一群能够非常成功地交付成果的项目领导者所组成的团体。为了能成功交付：</p>
<p>我们通过关注持续的价值流，以此来提高投资回报率。<br>我们通过与客户的频繁交互和分享所有权，以此来交付可靠的结果。<br>我们预先考虑不确定性的因素，并通过迭代、预防和适应的方式管理它。<br>我们承认个人是价值的最终源泉，努力建立一个人尽其才的环境，以此释放创造力和创新力。<br>我们通过团队结果问责制以及团队责任分享制，以此来提升绩效。<br>我们按照具体情况制定策略、过程和实践，以此来提高效率和可靠性。 </p>
</blockquote>
</li>
<li><p>精益<br>好吧。无论是精益软件开发7原则，还是丰田精益方法的14原则都没有提到“价值”这两个字。<br>但是，在《精益思想》进行了这样的总结 —— 5个原则：</p>
<blockquote>
<p>精确地定义特性产品的价值；<br>识别出每种产品的价值流；<br>使价值不间断地流动；<br>让客户从生产者方面拉动价值；<br>永远追求尽善尽美。</p>
</blockquote>
</li>
</ol>
<p>从前两组概念 —— 敏捷和敏捷项目管理，来直接追溯价值交付，看起来总是有些刻意。<br>而精益思想的第一原则“精确地定义特性产品的价值”，直接从用户受众的角度入手，就看起来直观的多，因此我这里就直接从精益来看价值交付是什么。</p>
<h3 id="价值交付的具象产出部分-——-产品"><a href="#价值交付的具象产出部分-——-产品" class="headerlink" title="价值交付的具象产出部分 —— 产品"></a>价值交付的具象产出部分 —— 产品</h3><p>说到精益，如果用一句话来描述它是用来干什么的话，那应该是：<code>杜绝浪费，降本增效。</code><br>当然，如果提到它诞生的背景的话，它解决了工业化大生产中的提前批量性生产、生产时间周期过长、生产可预测性不准等问题，但解决问题的终极思路就是：<code>在保证价值的同时，持续不断、稳定地消除浪费，从而降低成本提升效能。</code></p>
<p>说到“浪费”：丰田模式中，将生产活动中的各环节分为3类步骤：</p>
<ul>
<li>明确能创造价值的步骤</li>
<li>虽然不能创造价值，但是在现有技术和生产条件下不可避免的步骤（<strong>1型浪费</strong>）</li>
<li>不创造价值，并且可以去掉的步骤（<strong>2型浪费</strong>）<br>针对产品制造的第一要务就是首先定义价值，从而识别整个生产活动中能够创造价值的步骤、1型浪费和2型浪费。然后消除2型浪费，并将1型浪费逐渐转化成2型浪费从来最终消除。</li>
</ul>
<h4 id="首先定义价值"><a href="#首先定义价值" class="headerlink" title="首先定义价值"></a>首先定义价值</h4><p><img src="/2020/02/08/%E4%BB%8E%E7%B2%BE%E7%9B%8A%E6%9D%A5%E7%9C%8B%E4%BB%B7%E5%80%BC%E4%BA%A4%E4%BB%98%E6%98%AF%E4%BB%80%E4%B9%88/value.png" alt="价值"></p>
<p>同样的道理，在软件交付中，首先的出发点就是价值，并不是一堆一堆的功能集、features 或者 看起来非常 fashion 但不解决自身问题的前沿方案。</p>
<p>然而无论是制造业还是软件业，价值只能由产品的使用者 —— 最终用户来确定。<br>一般在交付团队中，会有两种情况：</p>
<ul>
<li>客户就是用户 </li>
<li>客户只是尝试设计产品，用户是另外的群体。<br>在客户不是用户的情况下，如果客户并没有收集和分析用户的真实需求，整个交付过程就会变成 —— 提前生产、没有以需求来拉动生产，最终价值交付物是否能产生价值只能凭玄学的地步。一旦不能产生价值，就变成了最大的浪费。<br><img src="/2020/02/08/%E4%BB%8E%E7%B2%BE%E7%9B%8A%E6%9D%A5%E7%9C%8B%E4%BB%B7%E5%80%BC%E4%BA%A4%E4%BB%98%E6%98%AF%E4%BB%80%E4%B9%88/pull-push.png" alt="用户拉动 vs 提前生产后推动"></li>
</ul>
<p>交付价值，只有在用 —— <code>具有特定价格、能在特定时间内满足用户需求的特定产品</code>（无论商品或者服务）来表达时才有意义。<br>所以，在交付之前，先确定产品的价值 —— 开发的人力成本、时间成本、机会成本，和最重要的一点 —— 这是否解决了用户的真实问题吗？以及是否“更好地”解决了用户的真实问题？<br>为什么这里有“更好地”一说？<br>就比如同样是员工打卡系统，在开发各成本投入产出比相似的情况下，上AI人脸识别 —— 自然是比手工签到的价值要大的。</p>
<p>也许有人会说，“我们使用敏捷，就是因为当下无法定义出明确产生价值的需求，才使用敏捷软件交付 —— 实现增量性发布、快速实验和反馈。”<br>这里要分两种情况来看这个问题：</p>
<ul>
<li>第一种情况：只是短视的一种借口。懒于、或者能力不足直接放弃努力，造成无法通过问题收集、需求分析和商业洞见对各种业务方案进行过滤，从源头上就开始产生软件开发的大量浪费。</li>
<li>第二种情况：已经有了需求收集和分析渠道，但行业方案较新，无法完全避免产品实验开发的浪费。这种，在更下游、更靠近用户的地方，是否建立了有效的用户反馈、价值追踪和核定机制 —— 实验的效果是什么样的，生成了哪些价值，是否帮助我们更好地逐渐形成价值定义？</li>
</ul>
<p>实现完价值定义之后，我们针对当前价值定义来看看“交付”这个动作。</p>
<h4 id="从需求到产品的快速研发能力"><a href="#从需求到产品的快速研发能力" class="headerlink" title="从需求到产品的快速研发能力"></a>从需求到产品的快速研发能力</h4><h5 id="“识别出每种产品的价值流”"><a href="#“识别出每种产品的价值流”" class="headerlink" title="“识别出每种产品的价值流”"></a>“识别出每种产品的价值流”</h5><p>用过 Scrum 或者 Kanban board 的人应该都理解，一张卡（无论 EPIC 卡还是 story 卡），其承载的就是一个价值点（这里不涉及到估算）。</p>
<p>而将 board 上的各个 columns 对应的步骤连接起来，其实就组成了完成此类卡的一条粗粒度的“价值流”。其中，有产生价值的In Dev、In QA等，也有1型浪费Dev Done / Ready for QA 等等，当然个别团队可能还存在2型浪费的 columns。<br>价值流的目标就是让团队识别出流程步骤，为之后消除这些浪费做准备，最终降低开发成本、缩短lead time。<br>那从这种粗粒度的”价值流“中如何逐渐暴露浪费和执行改进呢？</p>
<h5 id="“使价值不间断地流动”"><a href="#“使价值不间断地流动”" class="headerlink" title="“使价值不间断地流动”"></a>“使价值不间断地流动”</h5><p>也许有人会觉得这句话理解起来很难，其实在部分团队内非常常见。<br>比如：见过一些客户团队，所有 story 的开发只要开发人员开发完毕，就推进Dev Done column 中，等到整体功能开发的差不多了，才引入 QA 来开始测试，在此之前 QA 资源可能在忙于另一个团队的测试工作。一种类似制造业批量化生产的模式，生产步骤之间存在大量库存，批量满额之后，才会推进到下一个生产环节。<br>也有一些敏捷团队，由于 QA 资源不足，出现相同的Dev Done之后在Ready for QA中形成批量等待，始终无人解决，甚至大家对此已经习以为常 —— QA会在下一个sprint整体测试这批卡。<br>“使价值不间断地流动”，其实不仅是行动、更是从思想和意识上认识到 —— 价值要流动起来。就像最后那些敏捷团队的例子，即使使用了敏捷流程和工具，思想和意识不到位，依然用出了批量的样子。</p>
<p>有人会说：“这种批量有什么不好？团队上所有的人都在工作，并没有空转，人力没有被浪费。“<br>如果一定要从项目人力运营的知识域中来看价值交付，我只想说：是的，大家看起来都忙忙碌碌，行色匆匆，努力“做事”，但是人力花完就代表创造了价值么？<br>另一方面，我也可以从”测试前置“、”一次性把事情做好“、”缺陷越晚修复，修复的成本越高“、”开发周期越长，越容易返工“等等方面来聊一聊不关注价值流会造成的种种人力成本、时间成本、机会成本上的浪费。</p>
<p>只有让价值尽量不间断地流动起来，从需求到生产，才会暴露问题 —— 让团队观察和思考这种端到端的整条价值生产活动中，哪些是产生价值的，哪些是浪费？持续地逐渐优化和消除浪费后，降低开发成本、提升研发效能。</p>
<h5 id="“让客户从生产者方面拉动价值”"><a href="#“让客户从生产者方面拉动价值”" class="headerlink" title="“让客户从生产者方面拉动价值”"></a>“让客户从生产者方面拉动价值”</h5><p>当研发效能提升、单个价值点能被快速完成端到端交付时，提前预测性质的功能设计（是否能最终产生价值靠玄学的那种）就可以完全被避免，由最下游的终端用户直接提出需求，从来拉动交付。</p>
<h4 id="方案、技术先进性的加持"><a href="#方案、技术先进性的加持" class="headerlink" title="方案、技术先进性的加持"></a>方案、技术先进性的加持</h4><p>在前面我讲board上面的价值流的时候，始终特指其是”粗粒度“的价值流。<br>为何？<br>因为无法从这些columns中看到：用A框架开发会比B节省多少开发成本、使用某个自动化测试方案可以节省多少测试成本，诸如此类的“细粒度”的价值流才会发现的浪费对比。<br>这种时候，各团队面临的问题各不相同，需要团队一线人员自身的方案和技术能力去扩展优势、消除浪费，不再局限于敏捷软件开发流程、scrum / kanban board来宏观指导和描述开发流程。</p>
<p>这里就涉及到精益思想的最后一个原则：<em>“永远追求尽善尽美”</em>。</p>
<h3 id="价值交付的土壤-——-团队能力-学习型组织"><a href="#价值交付的土壤-——-团队能力-学习型组织" class="headerlink" title="价值交付的土壤 —— 团队能力 / 学习型组织"></a>价值交付的土壤 —— 团队能力 / 学习型组织</h3><p>精益思想前四大原则都只是在讲 —— 如何消除产品生产过程的浪费，最终形成高效有价值的生产流程。一般完成前四原则，基本可以收获 <code>突破性改善</code>（指初次改革，调整生产活动后，一次性获取到的改善效果）。<br>精益思想用最后一个原则<code>“永远追求尽善尽美”</code>，才提到了如何 <code>持续性改善</code> 。</p>
<p>而《丰田模式》用了一整本书，来讲如何实现“追求尽善尽美”、实现“持续性改善” —— 即使完成了前面四个原则，或用了大量的精益工具和实践，只要没达到一点，就不是精益。精益 —— <code>打造一个真正的学习型组织。</code></p>
<p>这个“学习型组织”，不是说 —— 只是在组织内培养学习氛围，今天去学几种对价值流毫无帮助的语言或架构，明天去做一些对当前主业务毫无扩展的社区活动。也不是说，当某个团队需要一个大数据工程师时，需要从零开始培养，当第二个团队又需要一个大数据工程师时，再次另外培养。<br>而是说 —— 培养学习氛围、过程中不断创建“标准化”以达到“稳定”，然后让成员发挥创造性思维和创新能力以持续改进价值流的组织。</p>
<p>为什么说“团队能力/学习型组织”是价值交付的土壤呢？<br>假设某团队前四原则背后的工作并不是团队自发形成完成的，是由一个外部人员引入并督促实践完成，本团队并没有掌握其能力。当用户需求拉动生产越来越快时，必然会暴露进一步需要解决的瓶颈和浪费，这时候团队离开了外部人员根本无力继续持续改进从而稳定交付价值。</p>
<p>为了真正实现精益的持久性改善和价值交付，这需要一个自下而上的过程。<br>仅靠上级制定几个衡量指标，没有培养团队的学习和自组织能力，你永远也想像不到真正实践时会长成什么样子。<br>将团队的指标呈现想像成地上的树，如下图。<br>上级也许期望是扎根价值交付、持续性改进指标背后的问题。但团队也许只是做了一些流于表面的工作让指标变得好看。<br><img src="/2020/02/08/%E4%BB%8E%E7%B2%BE%E7%9B%8A%E6%9D%A5%E7%9C%8B%E4%BB%B7%E5%80%BC%E4%BA%A4%E4%BB%98%E6%98%AF%E4%BB%80%E4%B9%88/how-tree-grow.png" alt="你以为和实际的区别"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>何为价值交付？<br>以打造学习型组织或团队为基石 —— 精确定义产品用户价值，尽可能以追求价值卓越为目标，从需求提出开始到产品上线被终端使用，持续消除或者减少阻碍产品研发的浪费，最终实现产品价值。</p>
<p>看起来，精益贯穿始终。<br>再回来看看《敏捷宣言》和《相互依赖声明》，发现和精益很多方面都很相似。只不过在我看来，精益可以更好的端到端描述整个价值流思路。</p>
]]></content>
      <categories>
        <category>敏捷精益软件</category>
      </categories>
      <tags>
        <tag>价值交付</tag>
        <tag>精益</tag>
      </tags>
  </entry>
</search>
